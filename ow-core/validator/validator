#!/usr/bin/python3

import jsonschema
import yaml
import json
import os
import sys

# Custom Exception Handling for smoother debugging
class DuplicateNameException(Exception):
    def __init__(self, message):
        super().__init__(message)


class OverwatchValidator:
    def __init__(self, rules):
        self.rules = rules

    # Taken from: https://stackoverflow.com/questions/1724693/find-a-file-in-python
    # Used to find path of 'rules.yaml' file in the root of user's project directory.
    # Intelligently does this (no hardocded paths), thus, it does not matter whether user is on Windows or Linux
    def find(self, name, path):
        for root, dirs, files in os.walk(path):
            if name in files:
                return os.path.join(root, name)

    def load_rules(self):
        with open(str(self.find(self.rules, os.path.abspath(os.curdir)))) as f:
            rules = yaml.load(f, Loader=yaml.FullLoader)
        return json.dumps(rules)

    def validate_rules_structure(self):
        with open(str(self.find("schema.yaml", os.path.abspath(os.curdir)))) as f:
            schema = yaml.load(f, Loader=yaml.FullLoader)
            try:
                rules = self.load_rules()
                cleaned_rules = json.loads(rules)
                jsonschema.validate(instance=cleaned_rules[0], schema=schema)
            except jsonschema.ValidationError as error:
                print(error)
                err = "Invalid Rules File"
                return False, err
            message = "Valid Rules File"
            return True, message

    def validate_alarm_attributes(self):
        rules = self.load_rules()
        cleaned_rules = json.loads(rules)
        alarmNames = []
        for rule in cleaned_rules:
            if rule["Alarm"]["AlarmName"] not in alarmNames:
                alarmNames.append(rule["Alarm"]["AlarmName"])
            else:
                raise DuplicateNameException("AlarmName must be unique.")

    def validate_metric_attributes(self):
        rules = self.load_rules()
        cleaned_rules = json.loads(rules)
        metricNames = []
        for rule in cleaned_rules:
            if rule["Metric"]["filterName"] not in metricNames:
                metricNames.append(rule["Metric"]["filterName"])
            else:
                raise DuplicateNameException("filterName must be unique.")

    # get_local_alarm_names and get_local_metric_names are simply helper functions for developers
    # these two functions are NOT used in validation step
    def get_local_alarm_names(self):
        result = []
        rules = self.load_rules()
        cleaned_rules = json.loads(rules)
        for rule in cleaned_rules:
            result.append(rule["Metric"]["filterName"])
        return result

    def get_local_metric_names(self):
        result = []
        rules = self.load_rules()
        cleaned_rules = json.loads(rules)
        for rule in cleaned_rules:
            result.append(rule["Alarm"]["AlarmName"])
        return result

    def validate(self):
        # Any other functions that are apart of the validation process add it here
        self.validate_alarm_attributes()
        self.validate_metric_attributes()
        is_valid, msg = self.validate_rules_structure()
        # TODO: perhaps actual and real error messaging?
        print(msg)
        if not is_valid:
            exit(1)
        exit(0)


if __name__ == "__main__":
    # validator class instance
    validator = OverwatchValidator()

    # if no args given, error out
    if len(sys.argv) != 2:
        raise "Usage: ./validator <path_to_rules>"

    # if path given, attempt to validate
    validator.validate(sys.argv[1])
